#include <iostream>

using namespace std;

template<typename T>
void foo(T);

/*
	In another word, when we use template function or class, compiler will create a new function / class based on the type we passed into template.
	When we call the function, we are actually using the function instance generated by the template but not the template itself.
	Rule: So both template definition and the function/class instance created by template based on the type we pass to it has to be in the same translation unit!
	
	When the definition is in the main.cpp or this header file, the main translation unit includes:
		1. declaration 
		2. definition	
		3. function instance generated by the template (of the type we passed to it when we use it)

	But when definition is in the template_decl_defn.cpp file, and that cpp file don't have an function instance generated by the template
	In the main translation unit we now ONLY have
		1. declaration 
		2. function instance generated by the template (of the type we passed to it when we use it)
	Without the definition function instance can't be created!

	And in our solution, there's a function instance right under the template definition
	so in our template_decl_defn translation unit, we have:
		1. declaration 
		2. definition	
		3. function instance generated by the template (of the type we passed to it when we use it)
	It matches the rules above

	So when we use the same template function type (same as template class), the linker will link the function instance in our 
	template_decl_defn translation unit with main translation unit, and we can use this function instance in our main.

*/